ORM(Object Relation Mapping)

영속성(Persistence) : 데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 속성을 말한다.

* 데이터를 영속성을 갖지 않는 데이터는 단지 메모리에서만 존재하기 때문에 프로그램을 종료시 모두 잃어버린다.
* Object Persistence(영구적인 객체) : 메모리 상의 데이터를 파일 시스템, 관계형 데이터베이스 혹은 객체 데이터베이스 등을 활용하여 영구적으로 저장하여
 영속성을 부여한다.

데이터를 데이터베이스에 저장하는 3가지 방법

1. JDBC(java에서 사용)
2. Spring JDBC (Ex.JdbcTemplate) 
3. Persistence Framework(Ex. Hibernate, Mybatis 등)

Persistence Layer
프로그램의 아키텍처에서, 데이터에 영속성을 부여해주는 계층을 말한다.
JDBC를 이용하여 직접 구현할 수 있지만 Persistence framework를 이용한 개발이 많이 이루어진다.

Persistence Framework
JDBC 프로그래밍의 복잡함이나 번거로움 없이 간단한 작업만으로 데이터베이스와 연동되는 시스템을 빠르게 개발할 수 있으며 안정적인 구동을 보장

SQL Mapper 와 ORM으로 나눌 수 있다.
	Ex) JPA, Hibernate, Mybatis 등


ORM Object Relation Mapping 객체 - 관계 매핑

객체와 관계형 데이터베이스의 데이터를 자동으로 매핑(연결)시켜주는 것을 말한다
객체지향프로그램은 클래스, 관계형 데이터베이슨는 테이블을 사용하는데 객체 모델과 관계형 모델간 불일치가 존재한다
ORM을 통해 객체 간의 관계를 바탕으로 자동으로 SQL 을 생성하여 문제를 해결한다.

요약 클래스와 테이블간의 불일치 부분을 자동으로 SQL을 생성해서 연결해준다.

데이터베이스 데이터 <-- 매핑 --> Object 필드
* 객체를 통해 간접적으로 데이터베이스 데이터를 다룬다.
* Persistant API라고 할 수 있다.
  Ex) JPA, Hibernate 등

장점

* 객체지향적인 코드로 인해 더 직관적이고 로직에 집중할 수 있도록 도와준다
* 재사용 및 유지보수의 편리성이 증가한다
* DBMS에 대한 종속성이 줄어든다.

 DBMS에 의존하지 않음으로써 도메인과 비즈니스 로직 설계에 더 집중할 수 있는 장점
--> 요구사항 변화에 빠른 대처 가능한 장점
--> 복잡한 통계성 쿼리보다는 실시간 처리용 쿼리에 적합




SQL Mapper
	Object와 SQL의 필드를 매핑하여 데이터를 객체화 하는 기술
	객체와 테이블간의 관계를 매핑하는 것이 아니라, SQL문을 직접 작성하고 쿼리 수행결과를 어떠한 객체에 매핑하여 줄 지
	바인딩하느 방법 즉, SQL 의존적인 방법이다. ex) JdbcTemplate, Mybatis

Mybatis
	SQL을 xml파일로 분리하여 관리하고, SQL 결과와 객체 인스턴스의 매핑을 도와주는 역할을 수행, 동적쿼리를 지원하여 다이나믹하게 변경되는 쿼리 작성가능


ORM (Object Relation Mapping)
: Object와 DB테이블을 매핑하여 데이터를 객체화하는 기술.
CRUD 관련 메소드를 사용하면 자동으로 SQL이 만들어져 개발자가 반복적인 SQL을 직접 작성하지 않아도 되고, DBMS에 종속적이지 않다. 또한 복잡한 쿼리의 경우 JPQL을 사용하거나 SQL Mapper를 혼용하여 사용할 수 있다.
Java ORM 기술에 대한 인터페이스 표준을 JPA라고 하고, 이를 구현한 가장 대표적인 기술이 Hibernate이다.

JPA(Java Persistence API) API : 애플리케이션 소프트웨어를 빌드하고 통합하기 위한 정의 및 프로토콜 세트를 뜻한다.
Java 진영에서 ORM(Object-Relational Mapping) 기술 표준으로 사용하는 인터페이스 모음
자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스
인터페이스 이기 때문에 Hibernate, OpenJPA 등이 JPA를 구현함


DB INDEX 인덱스

인덱스란 SQL 명령문의 처리 속도를 향상시키기 위해서 컬럼에 대해서 생성하는 오라클 객체
책의 끝에 나오는 책위치 정보같은 느낌

장점
- 속도가 빨라진다
- 시스템에 걸리는 부하를 줄여서 시스템 전체 성능 향상

단점
- 추가적인 공간 필요
- 인덱스 생성하는데 시간이 걸린다.
- 데이터의 변경작업이 자주 일어날 경우에는 성능 저하

인덱스는 기본 키나 유일 키와 같은 제약 조건을 지정하면 따로 생성하지 않더라도 자동으로 생성
Create Index 명령어로 직접 생성 가능

DB 인덱스의 자료구조

1. 해시 테이블(hash Table)

해시 체이블은 Key와 Value를 한 쌍으로 데이터를 저장하는 자료구조이다. (Key, Value)로 쌍으로 표현하며, Key 값을 이용해 대응되는 value값을 구하는 방식이다.
해시 충돌이라는 변수가 존재하지만 평균적으로 0(1)의 매우 빠른 시간만에 원하는 데이터를 탐색할 수 있는 구조이다.

해시 테이블은 실제로 인덱스에서 잘  사용되지 않는다. 그 이유는, 해시 테이블은 등호(=) 연산에 최적화되어있기 때문이다.
데이터베이스에선 부등호(<, >) 연산이 자주 사용되는데, 해시 테이블 내의 데이터들은 정렬되어 있지 않으므로 특정 기준보다 크거나 작은 값을 빠른 시간 내에 찾을 수가 없다. 


2. B+ Tree

기존의 B-Tree는 어느 한 데이터의 검색은 효율적이지만, 모든 데이터를 한 번 순환해야 하므로 비효휼적이다. 이러한 B-Tree의 단점을 개선시킨
자료구조가 B+Tree다.

B+Tree 오직 node에만 데이터를 저장하고 leaf node가 아닌 node에서는 자식 포인터만 저장한다.
그리고 leaf node끼리는 Linked list로 연결되어있다.
또, B+Tree에서는 반드시 leaf node에만 데이터가 저장되기 때문에 중간 node 에서 key를 올바르게 찾아가기 위해서 key가 중복될 수 있다.

장점
1. leaf node를 제외하고 데이터를 저장하지 않기 때문에 메모리를 더 확보할  수 있다. 따라서 하나의 node에 더 많은 포인터를 가질 수 있기 때문에
트리의 높이가 더 낮아지므로 검색 속도를 높일 수 있다.

2. Full scan을 하는 경우 B+Tree는 leaf node에만 데이터가 저장되어 있고, leaf node끼리 linked list로 연결되어 있기 때문에 선형 시간이 소모된다.
반명 B-Tree는 모든 node를 확인해야 한다.

B+Tree를 쓰는 이유 : 인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생할 수 있다. 따라서 B+Tree의 Linked list를 이용하면
순차 검색을 효율적으로 할 수 있게 된다.









